# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['Record', 'Role', 'Status', 'unpack_from', 'pack', 'pack_rec', 'unpack_sz', 'unpack_rec', 'unpack_content',
           'print_bytes', 'FcgiHandler']

# Cell
from fastcore.foundation import *
from fastcore.utils import *
from fastcore.meta import *

import struct,socketserver
from enum import Enum
from collections import defaultdict
from io import BytesIO,TextIOWrapper

# Cell
Record = Enum('Record', 'BEGIN_REQUEST ABORT_REQUEST END_REQUEST PARAMS STDIN '
               'STDOUT STDERR DATA GET_VALUES GET_VALUES_RESULT')
Role = Enum('Role', 'RESPONDER AUTHORIZER FILTER')
Status = Enum('Status', 'REQUEST_COMPLETE CANT_MPX_CONN OVERLOADED UNKNOWN_ROLE')

# Cell
def unpack_from(fmt, s, offset=0, prefix="!"):
    "`struct.unpack_from` with `prefix`"
    return struct.unpack_from(prefix+fmt, s, offset)

# Cell
def pack(s, *args, prefix="!"):
    "`struct.pack` with `prefix`"
    return struct.pack(prefix+s, *args)

# Cell
_REC_STRUCT = 'BBHHbb'
_chk_typs = Record.STDIN,Record.DATA
_stream_typs = _chk_typs+(Record.PARAMS,Record.STDOUT,Record.STDERR)

# Cell
def pack_rec(typ, c=b''):
    "Create a fastcgi binary record containing optional content `c`"
    if isinstance(typ,Record): typ=typ.value
    return pack(_REC_STRUCT, 1, typ, 1, len(c), 0, 0) + c

# Cell
def unpack_sz(fmt, s, offset=0, prefix="!"):
    "`unpack_from`, returning new `offset` based on size of `fmt`"
    sz = struct.calcsize(fmt)
    res = unpack_from(fmt, s, offset, prefix)
    return offset+sz,(res[0] if len(res)==1 else res)

# Cell
def unpack_rec(c,i):
    "Unpack a fastcgi binary record starting at offset `i`"
    i,(_,typ,_,contentlen,padlen,_) = unpack_sz(_REC_STRUCT, c, i)
    i,content = unpack_sz(f'{contentlen}s{"x"*padlen}', c, i)
    return i,(Record(typ),content)

# Cell
def unpack_content(typ, c):
    "Unpack the content section of a fastcgi binary record of `typ`"
    if typ==Record.BEGIN_REQUEST: return unpack_from('Hb5s', c)[:2]
    if typ==Record.ABORT_REQUEST: return ()
    raise Exception(typ)

# Cell
def _loop_thru(data,f,i=0):
    "Loop thru `data`, calling `f`, which updates `i`"
    while i<len(data):
        i,res = f(data,i)
        yield res

def _param_sz(c,i):
    # See http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html#S3.4
    i,l = unpack_sz('b', c, i)
    return unpack_sz('L', c, i-1) & 0x7fffff if l>>7 else i,l

def _param(c, i):
    # See http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html#S3.4
    i,lk = _param_sz(c,i)
    i,lv = _param_sz(c,i)
    i,res = unpack_sz(f'{lk}s{lv}s', c, i)
    return i,res

def _params(c): return {k.decode():v.decode() for k,v in _loop_thru(c.getvalue(),_param)}
def _records(c): return _loop_thru(c,unpack_rec)

# Cell
class _Wrapper(TextIOWrapper):
    def close(self): self.flush()

# Cell
def print_bytes(s:str, stream):
    "Convert `s` to `bytes`, using `\r\n` for newlines"
    b = _Wrapper(stream, newline='\r\n', encoding='utf8')
    print(s, file=b)

# Cell
class FcgiHandler(socketserver.BaseRequestHandler):
    def setup(self):
        while not self._recv(self.request.recv(68000)): pass

    def finish(self):
        for o in self.stdout,self.stderr: o.send()
        send_content(self.request, Record.END_REQUEST, 0, Status.REQUEST_COMPLETE.value)
        self.stdin.seek(0)

    def __getattr__(self,k):
        try: return self.streams[Record[k.upper()]]
        except KeyError: raise AttributeError(k)

    def _recv(self,d):
        for typ,c in _records(d):
            if typ in (Record.PARAMS,*_chk_typs):
                self.streams[typ].write(c)
                if typ == Record.PARAMS and not c: self.environ = _params(self.streams[typ])
                elif typ in _chk_typs: self.sz += len(c)
            else: getattr(self,'_'+typ.name)(*unpack_content(typ,c))
        if self.sz>=self.length: return True

    def _ABORT_REQUEST(self): self.sz=self.length
    def _BEGIN_REQUEST(self,role,keep_conn):
        self.streams = L(_stream_typs).map_dict(_Stream, req=self.request)
        self.sz,self.environ = 0,{}
        assert Role(role)==Role.RESPONDER, f"{role} not supported"
        assert not keep_conn, "FCGI_KEEP_CONN not supported"

    @property
    def content(self): return self.stdin.getvalue()
    @property
    def length(self):  return int(self.environ.get('CONTENT_LENGTH', 1))

# Cell
@patch
def print(self:FcgiHandler,s=""):
    "Write a `str` to `self.stdout` as bytes, converting line endings to `\r\n`"
    print_bytes(s, self.stdout)

# Cell
@patch
def err(self:FcgiHandler,s=""):
    "Write a `str` to `self.stderr` as bytes, converting line endings to `\r\n`"
    print_bytes(s, self.stderr)