# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['Record', 'Role', 'Status', 'FcgiHandler']

# Cell
from fastcore.foundation import *
from fastcore.utils import *
from fastcore.meta import *

import struct,socketserver
from enum import Enum
from io import BytesIO,TextIOWrapper

# Cell
Record = Enum('Record', 'BEGIN_REQUEST ABORT_REQUEST END_REQUEST PARAMS STDIN '
               'STDOUT STDERR DATA GET_VALUES GET_VALUES_RESULT')
Role = Enum('Role', 'RESPONDER AUTHORIZER FILTER')
Status = Enum('Status', 'REQUEST_COMPLETE CANT_MPX_CONN OVERLOADED UNKNOWN_ROLE')

# Cell
def _S(fmt): return struct.Struct('!'+fmt) # use `struct` "network order"
_rec_struct = _S('BBHHbb')
_endreq_struct = _S('LBxxx')
_begreq_struct = _S('Hb5s')

_chk_typs = Record.STDIN,Record.DATA
_stream_typs = _chk_typs+(Record.PARAMS,Record.STDOUT,Record.STDERR)

# Cell
class _Parser:
    def __init__(self, c): self.c,self.i = c,0

    def unpack(self, fmt):
        if not isinstance(fmt,struct.Struct): fmt = _S(fmt)
        res = fmt.unpack_from(self.c, self.i)
        self.i += fmt.size
        return res[0] if len(res)==1 else res

    def loop(self, f):
        while self.i<len(self.c): yield f(self)

# Cell
def _record(self):
    _,typ,_,contentlen,padlen,_ = self.unpack(_rec_struct)
    return Record(typ),self.unpack(f'{contentlen}s{"x"*padlen}')

def _records(c): yield from _Parser(c).loop(_record)

# Cell
def _param_sz(self):
    # See http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html#S3.4
    l = self.unpack('b')
    if not l>>7: return l
    self.i -= 1
    return self.unpack('L') & 0x7fffff

def _param(self):
    # See http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html#S3.4
    lk,lv = _param_sz(self),_param_sz(self)
    return self.unpack(f'{lk}s{lv}s')

def _params(s):
    return {k.decode():v.decode() for k,v in _Parser(s.getvalue()).loop(_param)}

# Cell
def _unpack_content(typ, c):
    "Unpack the content section of a fastcgi binary record of `typ`"
    if typ==Record.BEGIN_REQUEST: return _begreq_struct.unpack(c)[:2]
    if typ==Record.ABORT_REQUEST: return ()
    raise Exception(typ)

def _pack_rec(typ, c=b''):
    "Create a fastcgi binary record containing optional content `c`"
    return _rec_struct.pack(1, typ.value, 1, len(c), 0, 0) + c

def _send_content(req, typ, *args):
    "Send the content section of a fastcgi binary record of `typ` to `req`"
    if typ==Record.END_REQUEST: c = _endreq_struct.pack(*args)
    else: c = args[0] if args else b''
    req.send(_pack_rec(typ, c))

# Cell
class _Wrapper(TextIOWrapper): close=TextIOWrapper.flush

def _print_bytes(s:str, stream):
    "Convert `s` to `bytes`, using `\r\n` for newlines"
    b = _Wrapper(stream, newline='\r\n', encoding='utf8')
    print(s, file=b)

# Cell
class _Stream(BytesIO):
    def __init__(self, typ:Record, req): self.typ,self.req=typ,req
    def _send(self, *args): _send_content(self.req, self.typ, *args)
    def send(self):
        for o in chunked(self.getvalue(), 2**15): self._send(bytes(o))
        self._send()

# Cell
class FcgiHandler(socketserver.BaseRequestHandler):
    def setup(self):
        while not self._recv(self.request.recv(2**17)): pass

    def finish(self):
        for o in self.stdout,self.stderr: o.send()
        _send_content(self.request, Record.END_REQUEST, 0, Status.REQUEST_COMPLETE.value)
        self.stdin.seek(0)

    def __getattr__(self,k):
        try: rec = Record[k.upper()]
        except KeyError: raise AttributeError(k)
        return self.streams[rec]

    def _recv(self,d):
        for typ,c in _records(d):
            if typ in (Record.PARAMS,*_chk_typs):
                self.streams[typ].write(c)
                if typ == Record.PARAMS and not c: self.environ = dict(_params(self.streams[typ]))
                elif typ in _chk_typs: self.sz += len(c)
            else: getattr(self,'_'+typ.name)(*_unpack_content(typ,c))
        if self.sz>=self.length: return True

    def _ABORT_REQUEST(self): self.sz=self.length
    def _BEGIN_REQUEST(self,role,keep_conn):
        self.streams = L(_stream_typs).map_dict(_Stream, req=self.request)
        self.sz,self.environ = 0,{}
        assert Role(role)==Role.RESPONDER, f"{role} not supported"
        assert not keep_conn, "FCGI_KEEP_CONN not supported"

    @property
    def content(self): return self.stdin.getvalue()
    @property
    def length(self): return int(self.environ.get('CONTENT_LENGTH', 1))

# Cell
@patch
def print(self:FcgiHandler,s=""):
    "Write a `str` to `self.stdout` as bytes, converting line endings to `\r\n`"
    _print_bytes(s, self.stdout)

# Cell
@patch
def err(self:FcgiHandler,s=""):
    "Write a `str` to `self.stderr` as bytes, converting line endings to `\r\n`"
    _print_bytes(s, self.stderr)