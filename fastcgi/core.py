# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['Record', 'Role', 'Status', 'readlen', 'ByteStream', 'FcgiHandler']

# Cell
from fastcore.foundation import *
from fastcore.utils import *
from fastcore.meta import *

import struct
from socketserver import BaseRequestHandler,UnixStreamServer,TCPServer
from enum import Enum
from io import BytesIO,TextIOWrapper

# Cell
Record = Enum('Record', 'BEGIN_REQUEST ABORT_REQUEST END_REQUEST PARAMS STDIN '
               'STDOUT STDERR DATA GET_VALUES GET_VALUES_RESULT')
Role = Enum('Role', 'RESPONDER AUTHORIZER FILTER')
Status = Enum('Status', 'REQUEST_COMPLETE CANT_MPX_CONN OVERLOADED UNKNOWN_ROLE')

# Cell
def _S(fmt): return struct.Struct('!'+fmt) # use `struct` "network order"
_rec_struct,_endreq_struct,_begreq_struct,_long_struct = _S('BBHHbb'),_S('LBxxx'),_S('Hb5s'),_S('L')
_streams_data = Record.STDIN,Record.DATA
_streams_in  = (Record.PARAMS,) + _streams_data
_streams = _streams_in + (Record.STDOUT,Record.STDERR,Record.END_REQUEST)

# Cell
def readlen(r):
    "Read the length of the next fcgi parameter"
    # See http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html#S3.4
    a = r(1)
    res = a[0]
    if res>>7: res =_long_struct.unpack(a+r(3))[0] & 0x7fffffff
    return res

# Cell
def _send_content(req, typ, *args):
    "Send the content section of a fastcgi binary record of `typ` to `req`"
    if typ==Record.END_REQUEST: c = _endreq_struct.pack(*args)
    else: c = args[0] if args else b''
    req.send(_rec_struct.pack(1, typ.value, 1, len(c), 0, 0) + c)

# Cell
class ByteStream(BytesIO):
    def __init__(self, typ:Record, req): self.typ,self.req = typ,req

    def _send(self, *args): _send_content(self.req, self.typ, *args)
    def send(self):
        for o in chunked(self.getvalue(), 2**15): self._send(bytes(o))
        self._send()

# Cell
class FcgiHandler(BaseRequestHandler):
    def setup(self):
        self.streams = L(_streams).map_dict(ByteStream, req=self.request)
        sz,self.length = 0,1
        while sz<self.length: sz += ifnone(self._recv(), 0)

    def finish(self):
        self['stdout'].send()
        self['stderr'].send()
        self['end_request']._send(0, Status.REQUEST_COMPLETE.value)
        self['stdin'].seek(0)

    def _recv(self):
        typ,c = recv_record(self.request.recv)
        if typ in _streams_in:
            self[typ].write(c)
            if typ==Record.PARAMS and not c:
                self.environ = params(self[typ].getbuffer())
                self.length = int(self.environ['HTTP_CONTENT_LENGTH'] or 0)
        if typ in _streams_data: return len(c)

    @property
    def content(self): return self['stdin'].getbuffer()
    def __getitem__(self,k): return self.streams[Record[k.upper()] if isinstance(k,str) else k]

# Cell
@patch
def write(self:FcgiHandler, b:bytes, err=False):
    "Write `b` to stderr (if `err`) or stdout (otherwise)"
    self['stderr' if err else 'stdout'].write(b)

# Cell
class _Wrapper(TextIOWrapper): close=TextIOWrapper.flush

def _print_bytes(s:str, stream):
    "Convert `s` to `bytes`, using `\r\n` for newlines"
    b = _Wrapper(stream, newline='\r\n', encoding='utf8')
    print(s, file=b)

# Cell
@patch
def print(self:FcgiHandler,s=""):
    "Write a `str` to `self.stdout` as bytes, converting line endings to `\r\n`"
    _print_bytes(s, self['stdout'])

# Cell
@patch
def err(self:FcgiHandler,s=""):
    "Write a `str` to `self.stderr` as bytes, converting line endings to `\r\n`"
    _print_bytes(s, self['stderr'])