# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['Request', 'Role', 'Status', 'unpack_from', 'pack', 'pack_rec', 'unpack_sz', 'unpack_rec', 'unpack_content',
           'FcgiHandler']

# Cell
from fastcore.foundation import *
from fastcore.utils import *
from fastcore.meta import *

import struct,socketserver
from enum import Enum
from collections import defaultdict

# Cell
Request = Enum('Request', 'BEGIN_REQUEST ABORT_REQUEST END_REQUEST PARAMS STDIN '
               'STDOUT STDERR DATA GET_VALUES GET_VALUES_RESULT')
Role = Enum('Role', 'RESPONDER AUTHORIZER FILTER')
Status = Enum('Status', 'REQUEST_COMPLETE CANT_MPX_CONN OVERLOADED UNKNOWN_ROLE')

# Cell
def unpack_from(fmt, s, offset=0, prefix="!"):
    "`struct.unpack_from` with `prefix`"
    return struct.unpack_from(prefix+fmt, s, offset)

# Cell
def pack(s, *args, prefix="!"):
    "`struct.pack` with `prefix`"
    return struct.pack(prefix+s, *args)

# Cell
_REC_STRUCT = 'BBHHbb'
_chk_typs = Request.STDIN,Request.DATA

# Cell
def pack_rec(typ, c=b''):
    "Create a fastcgi binary record containing optional content `c`"
    if isinstance(typ,Request): typ=typ.value
    return pack(_REC_STRUCT, 1, typ, 1, len(c), 0, 0) + c

# Cell
def unpack_sz(fmt, s, offset=0, prefix="!"):
    "`unpack_from`, returning new `offset` based on size of `fmt`"
    sz = struct.calcsize(fmt)
    res = unpack_from(fmt, s, offset, prefix)
    return offset+sz,(res[0] if len(res)==1 else res)

# Cell
def unpack_rec(c,i):
    "Unpack a fastcgi binary record starting at offset `i`"
    i,(_,typ,_,contentlen,padlen,_) = unpack_sz(_REC_STRUCT, c, i)
    i,content = unpack_sz(f'{contentlen}s{"x"*padlen}', c, i)
    return i,(Request(typ),content)

# Cell
def unpack_content(typ, c):
    "Unpack the content section of a fastcgi binary record of `typ`"
    if typ==Request.BEGIN_REQUEST: return unpack_from('Hb5s', c)[:2]
    if typ==Request.ABORT_REQUEST: return ()
    raise Exception(typ)

# Cell
def _loop_thru(data,f,i=0):
    "Loop thru `data`, calling `f`, which updates `i`"
    while i<len(data):
        i,res = f(data,i)
        yield res

def _param_sz(c,i):
    # See http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html#S3.4
    i,l = unpack_sz('b', c, i)
    return unpack_sz('L', c, i-1) & 0x7fffff if l>>7 else i,l

def _param(c, i):
    # See http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html#S3.4
    i,lk = _param_sz(c,i)
    i,lv = _param_sz(c,i)
    i,res = unpack_sz(f'{lk}s{lv}s', c, i)
    return i,res

def _params(c): return {k.decode():v.decode() for k,v in _loop_thru(c,_param)}
def _records(c): return _loop_thru(c,unpack_rec)

# Cell
class _Stream:
    def __init__(self): self.buf,self.done = b'',False
    def __repr__(self): return str(self.buf)
    def __str__(self): return self.buf.decode()

    def append(self,d):
        self.buf += d
        self.done = not d

# Cell
class FcgiHandler(socketserver.BaseRequestHandler):
    def setup(self):
        while not self._recv(self.request.recv(68000)): pass

    def finish(self):
        self._end(Request.STDOUT)
        self._end(Request.STDERR)
        self._send(Request.END_REQUEST, pack('LBBBB', 0, Status.REQUEST_COMPLETE.value, 0,0,0))

    def _recv(self,d):
        for typ,c in _records(d):
            if typ in (Request.PARAMS,*_chk_typs): self.streams[typ].append(c)
            else: getattr(self,'_'+typ.name)(*unpack_content(typ,c))
            if typ in _chk_typs: self.sz += len(c)
        if self.sz>=self.length: return True

    def __getitem__(self, k):
        if isinstance(k,str): k = Request[k.upper()]
        return self.streams[k] if k in self.streams else None

    def _ABORT_REQUEST(self): self.sz=self.length

    def _BEGIN_REQUEST(self,role,keep_conn):
        self.streams,self.sz = defaultdict(_Stream),0
        assert Role(role)==Role.RESPONDER, f"{role} not supported"
        assert not keep_conn, "FCGI_KEEP_CONN not supported"

    def send(self, c, err=False):
        "Queue content `c` for sending"
        stream = self.streams[Request.STDERR if err else Request.STDOUT]
        stream.append(c if isinstance(c,bytes) else bytes(c, 'utf8'))

    def _send(self, stream, c=b''): self.request.send(pack_rec(stream, c))

    def _end(self, stream):
        if stream not in self.streams: return
        for o in chunked(self[stream].buf, 64000): self._send(stream, bytes(o))
        self._send(stream)

    def __exit__(self, exc_type, exc_value, traceback): self.close()
    def __enter__(self): return self

    @property
    def stdin(self): return str(self['stdin'])
    @property
    def params(self):
        p = self['PARAMS']
        return _params(p.buf) if p else {}
    @property
    def length(self): return int(self.params.get('CONTENT_LENGTH', 1))